# Classify
---
목차
1. 프로젝트 배경 - 어떤 문제를 해결하려 하는가?
2. 프로젝트 설계 - 어떤 설계를 통해 문제를 해결할 것인가?
3. 마주쳤던 문제와 해결 과정
---

# 1. 프로젝트 배경 - 어떤 문제를 해결하려 하는가?

Classify는 다음의 2가지 문제를 해결하려는 의도를 갖고 제작되었습니다:
- 메모의 분류에 들어가는 수고를 줄여 더 많은 메모가 생산될 수 있도록 하겠다.
- 메모의 관리에 들어가는 수고를 줄여 메모의 화석화를 방지하겠다.

저는 메모를 자주 합니다. 오늘 할일, 프로젝트 진행, 공부하면서 얻은 깨달음 등 많은 내용을 메모하지만 기존의 메모앱은 상당히 불편한 점이 많았습니다. 노션과 옵시디언을 많이 사용했는데 제가 느끼기엔 각각 아래의 문제점들이 있었습니다.
- 노션: 페이지 안의 페이지 안의 페이지.. 이런 식으로 정보를 분류하다 보니 폴더 트리가 너무 깊어져 정작 필요할 때 원하는 정보를 찾기가 어려웠고 메모를 할 때 애초에 적절한 페이지를 찾아 들어가는 것도 일이었습니다.
- 옵시디언: 폴더 구조를 최대한 단순하게 만들어 위의 단점을 어느 정도 극복했지만 여전히 적절히 분류하는 것은 상당한 피로를 불러오는 일이었습니다.

결국 공부를 하다가 아하! 순간이 와서 기록을 해놓아도 나중에는 그 메모의 존재 자체를 잊어버리는 문제를 일상 속에서 겪어 왔습니다. 분류를 잘 한다고 해도 결국 자주 보지 않는 오래된 메모는 잊혀지게 되고 용량만 차지하는 애물단지가 됩니다. 즉, 화석화되는 문제가 있습니다.

# 2. 프로젝트 설계 - 어떤 설계를 통해 문제를 해결할 것인가?

## 2-1) 어떻게 메모의 분류에 들어가는 수고를 줄일 것인가?

- 이에 대한 답은 간단합니다. ai가 대신 분류하게 하는 것입니다. 사용자는 메모장에 메모 내용만 입력하면 ai가 메모 제목, 메모 태그, 메모 분류를 자동으로 생성하여 정리합니다. 이에 더하여 bottomAppbar 중앙에 메모 추가 버튼을 배치해서 사용자가 메모를 하는 데까지 걸리는 여정 또한 최소화하였습니다. 

## 2-2) 어떻게 메모의 관리에 들어가는 수고를 줄일 것인가?

- 이 앱에서 메모는 크게 할 일, 공부, 아이디어 세 가지 카테고리로 분류됩니다. 각각의 카테고리는 tabbarview로 화면상에 표시되는데 이때 공부, 아이디어 tabbarview 최상단에 랜덤 메모 출몰 구역을 지정하였습니다. 이렇게 하면 사용자는 예전에 작성했던 메모를 간접적으로 다시 보게 되고 이 메모의 필요성 유무를 판단할 수 있게 됩니다. 예전에 작성했지만 지금은 필요가 없다는 생각이 든다면 길게 눌러서 삭제하면 됩니다. 할 일 카테고리의 경우에는 메모의 수명이 짧다는 특성이 있기 때문에 시간순으로만 표시하게 놔두었습니다.
- 이 랜덤 메모 출몰 구역은 공부 카테고리와 아이디어 카테고리에서 각각 그 추가기능이 약간 다르게 진화되었습니다. 그 내용은 아래와 같습니다.

### 공부: 

공부의 경우에는 인출이 매우 중요하다고 생각합니다. 그래서 공부 카테고리의 경우에는 메모의 내용을 그대로 보여주는 것이 아니라 해당 메모 내용으로 ai가 만든 질문을 띄우고 짧게 1번 탭하면 메모 전체 내용을 볼 수 있도록 만들었습니다. 머릿속에 있는 내용을 인출하는 행위는 상당한 인지적 수고가 동반되는 작업이므로 구역 내 메모의 갯수는 하나로 최소화하였습니다.  

### 아이디어: 

아이디어의 경우에는 메모 간의 연결이 중요합니다. 그래서 사용자 스스로도 생각지 못했던 아이디어의 연결을 촉진시킬 수 있도록 랜덤 출몰 구역 내 메모의 갯수는 2개로 설계하였습니다.

# 3. 마주쳤던 문제와 해결 과정

## 3-1) 어떻게 앱을 갈아엎을 것인가?

- 이 앱은 원래 weathercloset이라는 ai 기반 스타일링 앱이 시작이었습니다. 기획자 1명, 디자이너 1명, 개발자인 저 이렇게 3명이서 스타트업을 차리기 위해 출발을 했는데 재정 운영에 대한 의견 차이로 인해 팀은 와해되었습니다. 이대로 버리기엔 너무 아까워서 제가 평소에 생각했던 문제를 해결해보는 데 사용해보자 하는 생각으로 이 앱을 만들었습니다.
- 이전 프로젝트인 cakeTimer의 경우 코드가 너무 어지러워서 손도 대지 못하는 수준이었는데 이번에는 달랐습니다. MVVM 패턴을 적용했기 때문입니다.
- 부족한 부분이 많지만, 공식 문서를 통해 학습한 내용을 바탕으로 MVVM 패턴을 적용했기 때문에 각 클래스의 책임과 영향 범위 그리고 역할을 명확하게 인지할 수 있었고 그렇기에 마치 레고 블록 조립하듯 제 코드를 변경할 수 있었습니다.
- 결과적으로 기존의 의도와는 전혀 다른 설계를 안착시키는 데 성공하였고, 올바른 디자인 패턴의 사용과 공식문서를 통한 학습의 중요성을 실감하는 중요한 계기가 되었습니다. 

## 3-2) 느리고 비싼 서버와의 동기화 로직을 어떻게 개선할 것인가?

- 처음에는 사용자가 작성한 메모를 서버에 보내고 다시 서버에서 해당 내용을 받아와 로컬 DB에 해당 메모를 쓰고 로컬 DB에서 그 메모를 불러와 방식으로 데이터 스트림을 짰습니다. 하지만 향후 이미지 관련 기능이 추가될 경우 위의 방식은 너무 느려서 사용자 경험을 크게 저해할 것이라는 생각이 들었고, 무엇보다 firebase는 읽기 및 쓰기 횟수를 기반으로 과금을 하는데 메모를 사용할 때마다 쓰기 및 읽기 즉 2개의 작업이 발생한다면 앞으로의 비용 구조에서 상당히 불리한 측면이 있겠다는 생각이 들었습니다.
- 그래서, 메모 분석 하나가 완료될 때마다 local DB와 서버에 같은 제목의 uuid로 저장한 후 불러오는 작업은 local DB에서만 수행함으로써 서버 측에서 발생하는 작업을 최소화시켰고, local DB에서 불러오므로 속도 측면에서도 
- 즉, 서버와 로컬 모두에 해당 데이터가 있음을 확인하고 나서야 사용자에게 보여주는 방식에서, 서버에 메모 내용이 정상적으로 올라갈 것이라는 믿음을 기반으로 local DB에서 사용자에게 보여주는 방식으로 변모했습니다. 
